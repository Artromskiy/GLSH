using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GLSH.Compiler.Internal;

internal partial class MethodWriter : CSharpSyntaxVisitor<string>
{
    private readonly Compilation _compilation;
    private readonly LanguageBackend _backend;
    private string containingType;

    public MethodWriter(Compilation compilation, LanguageBackend backend)
    {
        _compilation = compilation;
        _backend = backend;
    }

    private SemanticModel GetModel(SyntaxNode node) => _compilation.GetSemanticModel(node.SyntaxTree);
    private string? GetCsTypeName(TypeSyntax node) => GetModel(node).GetSymbolInfo(node).Symbol?.GetFullMetadataName();

    private string? GetGlTypeName(TypeSyntax node)
    {
        var csName = GetCsTypeName(node);
        return csName != null ? _backend.CSharpToShaderType(csName) : null;
    }

    public string WriteMethod(MethodDeclarationData methodDeclarationData)
    {
        var syntax = Utilities.GetMethodSyntax(methodDeclarationData, _compilation);

        var type = _compilation.GetTypeByMetadataName(methodDeclarationData.containingType);
        if (syntax == null && type != null && methodDeclarationData.methodName == GLSHConstants.Ctor)
            return WriteAutoGeneratedCtor(type);

        return Visit(syntax)!;
    }

    public override string? VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        var symbol = GetModel(node).GetDeclaredSymbol(node)!;
        var declaration = GetMethodDefinition(symbol);
        var body = GetMethodBodyBraced(symbol, node.Body, node.ExpressionBody);
        return declaration + body;
    }

    public override string? VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
        var symbol = GetModel(node).GetDeclaredSymbol(node)!;
        var declaration = GetMethodDefinition(symbol);
        var body = GetMethodBody(symbol, node.Body, node.ExpressionBody);
        var type = symbol.ContainingType.GetFullMetadataName();
        var thisToken = GLSHConstants.ThisToken;
        var thisDecl = $"{_backend.CSharpToShaderType(type)} {thisToken} = {_backend.FormatInvocation(type, GLSHConstants.Default, [])};".Indent();
        var initializers = WriteFieldInitializers(symbol.ContainingType);
        var returnString = $"return {thisToken};".Indent();
        return
        $$"""

        {{declaration}}
        {
        {{thisDecl}}
        {{initializers}}
        {{body}}
        {{returnString}}
        }

        """;
    }

    public override string? VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
        var symbol = GetModel(node).GetDeclaredSymbol(node)!;
        var declaration = GetMethodDefinition(symbol);
        var body = GetMethodBodyBraced(symbol, node.Body, node.ExpressionBody);
        return declaration + body;
    }

    private string GetMethodDefinition(IMethodSymbol method)
    {
        var returnType = method.ReturnType.GetFullMetadataName();
        containingType = method.ContainingType.GetFullMetadataName();
        List<InvocationParameter> parameters = [];

        if (!method.IsStatic && method.MethodKind != MethodKind.Constructor) // convert to extension-like thing
            parameters.Add(new(containingType, GLSHConstants.ThisToken, ParameterDirection.InOut));

        parameters.AddRange(method.Parameters.Select(p =>
        {
            var direction = Utilities.RefKindToDirection(p.RefKind);
            var typeName = p.Type.GetFullMetadataName();
            var identifier = p.Name;
            return new InvocationParameter(typeName, identifier, direction);
        }));

        return _backend.FormatDeclaration(returnType, containingType, method.Name, [.. parameters]);
    }

    private string? GetMethodBodyBraced(IMethodSymbol symbol, BlockSyntax? block, ArrowExpressionClauseSyntax? arrow)
    {
        return
        $$"""

        {
        {{GetMethodBody(symbol, block, arrow)}}
        }

        """;
    }

    private string GetMethodBody(IMethodSymbol symbol, BlockSyntax? block, ArrowExpressionClauseSyntax? arrow)
    {
        if (block != null)
        {
            StringBuilder sb = new();
            foreach (var statement in block.Statements)
                sb.AppendLine(Visit(statement).Indent());
            return sb.ToString();
        }
        bool isVoid = symbol.ReturnType.GetFullMetadataName() == typeof(void).FullName!;
        var returnKeyword = isVoid ? "" : "return ";
        return $"{returnKeyword}{Visit(arrow!.Expression)};".Indent();
    }

    private string WriteAutoGeneratedCtor(INamedTypeSymbol symbol)
    {
        var type = symbol.GetFullMetadataName();
        var declaration = _backend.FormatDeclaration(type, type, GLSHConstants.Ctor, []);
        var thisToken = GLSHConstants.ThisToken;
        var thisDecl = $"{_backend.CSharpToShaderType(type)} {thisToken} = {_backend.FormatInvocation(type, GLSHConstants.Default, [])};".Indent();
        var initializers = WriteFieldInitializers(symbol);
        var returnString = $"return {thisToken};".Indent();
        return
        $$"""

        {{declaration}}
        {
        {{thisDecl}}
        {{initializers}}
        {{returnString}}
        }

        """;
    }


    private string WriteFieldInitializers(INamedTypeSymbol typeSymbol)
    {
        StringBuilder sb = new();

        var members = typeSymbol.GetMembers().Where(s => s.Kind == SymbolKind.Field || s.Kind == SymbolKind.Property);
        foreach (var item in members)
        {
            var syntax = item.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax();
            if (syntax is VariableDeclaratorSyntax varDeclarator)
            {
                var initializers = VariableInitializers(varDeclarator);
                if(!string.IsNullOrEmpty(initializers))
                    sb.AppendLine(initializers);
            }
            else if (syntax is PropertyDeclarationSyntax propertyDeclaration)
            {
                var initializers = PropInitializers(propertyDeclaration);
                if(!string.IsNullOrEmpty(initializers))
                   sb.AppendLine(initializers);
            }
        }

        return sb.ToString();
    }

    private string VariableInitializers(VariableDeclaratorSyntax node)
    {
        var thisToken = GLSHConstants.ThisToken;
        if (node.Initializer == null)
            return "";
        return $"{thisToken}.{Visit(node)};".Indent();
    }

    private string PropInitializers(PropertyDeclarationSyntax node)
    {
        if (node.Initializer == null)
            return "";
        if (!Utilities.IsAutoProperty(node))
            return "";

        var thisToken = GLSHConstants.ThisToken;
        var fieldName = node.Identifier.ToString();
        return $"{thisToken}.{fieldName} {Visit(node.Initializer)};".Indent();
    }
}