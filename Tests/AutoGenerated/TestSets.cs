using Microsoft.CodeAnalysis;
using System.Collections;
using System.Collections.Generic;

namespace Tests.AutoGenerated
{
    internal class TestSets : IReadOnlyList<TestSet>
    {
        private readonly IReadOnlyList<TestSet> _sets;
        public readonly Compilation compilation;
        public readonly Mappings mappings;
        public readonly byte[] testData;
        public readonly int testLoops;

        /// <summary>
        /// The minimum mantissa of generated floats.
        /// </summary>
        public readonly int MinMantissa;

        /// <summary>
        /// The maximum mantissa of generated floats.
        /// </summary>
        public readonly int MaxMantissa;

        /// <summary>
        /// Initializes a new instance of the <see cref="TestSets" /> class.
        /// </summary>
        /// <param name="toolChains">The tool chains.</param>
        /// <param name="compilation">The compilation.</param>
        /// <param name="mappings">The mappings.</param>
        /// <param name="testLoops">The test loops.</param>
        /// <param name="minMantissa">The minimum mantissa.</param>
        /// <param name="maxMantissa">The maximum mantissa.</param>
        public TestSets(Compilation compilation, Mappings mappings, int testLoops, int minMantissa, int maxMantissa)
        {
            this.compilation = compilation;
            this.mappings = mappings;
            this.testLoops = testLoops;
            MinMantissa = minMantissa;
            MaxMantissa = maxMantissa;

            testData = new byte[mappings.BufferSize * testLoops];

            // Create a set for the CPU and then sets for each tool chain.
            _sets = [new TestSet(this)];

            // Generate the test data and the result set data for the CPU.
            testData = new byte[mappings.BufferSize * testLoops];
            for (int test = 0; test < testLoops; test++)
            {
                foreach (MethodMap method in mappings.MethodMaps)
                {
                    method.GenerateTestData(testData, test, minMantissa, maxMantissa);
                }
            }
        }

        public IReadOnlyDictionary<MethodMap, IReadOnlyList<Failure>> GetFailures(float epsilon = float.Epsilon)
        {
            Dictionary<MethodMap, IReadOnlyList<Failure>> dictionary = [];
            List<Failure> failures = [];
            FloatComparer comparer = new(epsilon);
            // Get pointer array
            foreach (MethodMap method in mappings.MethodMaps)
            {
                if (method.ResultField == null)
                {
                    // This method has no results, so just skip it
                    continue;
                }

                for (int test = 0; test < testLoops; test++)
                {
                    // Calculate more detailed failure analysis
                    Failure failure = Failure.Test(this, method, test, comparer);
                    if (failure != null)
                    {
                        failures.Add(failure);
                    }
                }

                if (failures.Count == 0)
                {
                    continue;
                }

                dictionary[method] = [.. failures];
                failures.Clear();
            }

            return dictionary;
        }

        public IEnumerator<TestSet> GetEnumerator() => _sets.GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        public int Count => _sets.Count;
        public TestSet this[int index] => _sets[index];
    }
}
